<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.bc.pmpheep.back.commuser.readpage.dao.ReadDao">
    <!-- 根据某类下的重点推荐图书 -->
    <select id="queryZdtjReadList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT t.type_name,b.* FROM book AS b
        inner JOIN material_type AS t ON b.type = t.id
        and SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(t.path,'-',t.id),'-',
        (select cast(
        (CHAR_LENGTH(path)-CHAR_LENGTH(REPLACE(path,'-','')))/CHAR_LENGTH('-')+2
        as decimal(9,2)
        )
        from material_type where id = cast('${type}' as decimal(9,2)))),'-',-1) = '${type}'
        WHERE b.is_promote = 1  and  b.is_on_sale =1
        AND (b.deadline_promote > now() or b.deadline_promote is null)
        ORDER BY b.sort_promote ASC
        <if test="startrows != null and startrows != ''">
            <![CDATA[limit ${startrows},${endrows}]]>
        </if>

    </select>

	<!-- 将分类以层级包装成层层嵌套的List<Map<String, Object>> -->
	<resultMap type="Map" id="CCMTMap">
		<id property="id" column="id0"/>
		<result property="path" column="path0"/>
		<result property="type_name" column="type_name0"/>
		<collection property="dataList" ofType="Map" javaType="ArrayList">
			<id property="id" column="id1"/>
			<result property="path" column="path1"/>
			<result property="type_name" column="type_name1"/>
			<collection property="dataList" ofType="Map" javaType="ArrayList">
				<id property="id" column="id2"/>
				<result property="path" column="path2"/>
				<result property="type_name" column="type_name2"/>
				<collection property="dataList" ofType="Map" javaType="ArrayList">
					<id property="id" column="id3"/>
					<result property="path" column="path3"/>
					<result property="type_name" column="type_name3"/>
				</collection>
			</collection>
		</collection>
	</resultMap>

    <select id="queryMaterialType" resultMap="CCMTMap">
    		
		select 
		t0.id as id0,t0.path as path0 ,t0.type_name as type_name0
		,t1.id as id1,t1.path as path1 ,t1.type_name as type_name1
		,t2.id as id2,t2.path as path2 ,t2.type_name as type_name2
		,t3.id as id3,t3.path as path3 ,t3.type_name as type_name3
		,p.*
		from
		(
		select * from 
		material_type m 
		where m.path = '0'
		)t0 
		
		left join 
		(
		select * from material_type m 
		where path REGEXP  '^0(-[^-]*){1}$'
		)t1 
		on t0.id = t1.parent_id
		
		left join
		(
		select * from material_type m 
		where path REGEXP  '^0(-[^-]*){2}$'
		)t2
		on t1.id = t2.parent_id

		left join 
		(
		select * from material_type m 
		where path REGEXP  '^0(-[^-]*){3}$'
		)t3
		on t2.id = t3.parent_id
		
		inner join 
		(
		select concat(m.path,'-',m.id,'-') full_path from material_type m 
		inner join book b on b.type = m.id and b.is_on_sale =1
		group by m.id
		)p
		on p.full_path REGEXP concat('^.*-',t3.id,'-.*')

		where t0.id in (${firstTypeIds})
		
		order by t0.sort, t1.sort , t2.sort , t3.sort 

		<!-- <![CDATA[

		select * from material_type where length(path) < 20 order by length(path),parent_id,length(note),sort

        ]]> -->
	</select>

    <!-- 根据某类下的新书推荐 -->
    <select id="queryXstjReadList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT t.type_name,b.* FROM book AS b
        inner JOIN material_type AS t ON b.type = t.id
        and SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(t.path,'-',t.id),'-',
        (select cast(
        (CHAR_LENGTH(path)-CHAR_LENGTH(REPLACE(path,'-','')))/CHAR_LENGTH('-')+2
        as decimal(9,2)
        )
        from material_type where id = cast('${type}' as decimal(9,2)))),'-',-1) = '${type}'
        WHERE b.is_new = 1  and  b.is_on_sale =1
        AND (b.deadline_new > now() or b.deadline_new is null)
        ORDER BY b.sort_new ASC
        <if test="startrows != null and startrows != ''">
            <![CDATA[limit ${startrows},${endrows}]]>
        </if>
    </select>

    <!-- 热门书评 -->
    <select id="queryRmspReadList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT u.id,b.id id1,b.bookname,b.image_url,c.content,c.score,u.nickname
        FROM book AS b INNER JOIN
        (SELECT * from book_user_comment
        GROUP BY book_id
        HAVING is_auth = 1 AND
        is_hide = 0 AND
        is_deleted = 0)AS c
        ON b.id = c.book_id
        INNER JOIN writer_user AS u ON c.writer_id = u.id
        ORDER BY
        b.comments ASC
        <if test="startrows != null and startrows != ''">
            <![CDATA[limit ${startrows},${endrows}]]>
        </if>
    </select>

    <!-- 图书畅销 -->
    <select id="queryTscxReadList" parameterType="java.util.Map" resultType="java.util.Map">
        SELECT t.type_name,b.* FROM book AS b
        inner JOIN material_type AS t ON b.type = t.id
        and SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(t.path,'-',t.id),'-',
        (select cast(
        (CHAR_LENGTH(path)-CHAR_LENGTH(REPLACE(path,'-','')))/CHAR_LENGTH('-')+2
        as decimal(9,2)
        )
        from material_type where id = cast('${type}' as decimal(9,2)))),'-',-1) = '${type}'
        where b.is_on_sale = 1 ORDER BY b.sales DESC
        <if test="startrows != null and startrows != ''">
            <![CDATA[limit ${startrows},${endrows}]]>
        </if>
    </select>
</mapper>